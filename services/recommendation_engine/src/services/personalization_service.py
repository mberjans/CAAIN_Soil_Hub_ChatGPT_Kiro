"""Advanced personalization and learning service for recommendations.

This module provides adaptive personalization capabilities that learn from
farmer preferences, interactions, and feedback. It is designed to operate on
`RecommendationItem` objects generated by the recommendation engine and to
produce detailed personalization summaries for downstream consumers.
"""

from __future__ import annotations

import asyncio
import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple
from uuid import uuid4

try:
    from ..models.agricultural_models import RecommendationItem, RecommendationRequest
except ImportError:  # pragma: no cover - fallback during standalone execution
    from models.agricultural_models import RecommendationItem, RecommendationRequest

logger = logging.getLogger(__name__)


@dataclass
class UserPreference:
    """Normalized user preference profile used for personalization."""

    user_id: str
    risk_tolerance: str = "moderate"
    management_style: str = "balanced"
    organic_focus: bool = False
    yield_priority: float = 0.5
    sustainability_priority: float = 0.5
    profit_priority: float = 0.5
    cost_sensitivity: float = 0.5
    preferred_crops: List[str] = field(default_factory=list)
    focus_keywords: List[str] = field(default_factory=list)
    constraints: Dict[str, Any] = field(default_factory=dict)
    last_updated: datetime = field(default_factory=datetime.utcnow)


@dataclass
class RecommendationFeedback:
    """Feedback event captured from user interactions."""

    user_id: str
    recommendation_key: str
    rating: float
    accepted: bool
    timestamp: datetime = field(default_factory=datetime.utcnow)
    comments: Optional[str] = None


@dataclass
class RecommendationInteraction:
    """Delivery interaction recorded for personalization learning."""

    user_id: str
    recommendation_key: str
    delivered_at: datetime
    confidence_score: float
    context: Dict[str, Any] = field(default_factory=dict)


class PersonalizationService:
    """Service that personalizes recommendation lists and learns over time."""

    def __init__(self) -> None:
        self._user_preferences: Dict[str, UserPreference] = {}
        self._interaction_history: Dict[str, List[RecommendationInteraction]] = {}
        self._feedback_history: Dict[str, List[RecommendationFeedback]] = {}
        self._collaborative_matrix: Dict[str, Dict[str, float]] = {}
        self._lock = asyncio.Lock()

    async def learn_user_preferences(self, user_id: str, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create or update a user's preference profile from raw data."""
        async with self._lock:
            preference = self._parse_user_preference(user_id, user_data)
            self._user_preferences[user_id] = preference
            logger.info("Stored preference profile for user %s", user_id)
        return {"status": "preferences learned", "user_id": user_id}

    async def adapt_recommendations(
        self,
        recommendations: List[Dict[str, Any]],
        user_preferences: Dict[str, Any],
    ) -> List[Dict[str, Any]]:
        """Apply lightweight personalization adjustments to raw dictionaries."""
        if recommendations is None:
            return []
        preference = self._parse_user_preference("temporary", user_preferences)
        scored_entries: List[Tuple[float, Dict[str, Any]]] = []
        index = 0
        while index < len(recommendations):
            record = recommendations[index]
            score = record.get("confidence_score", 0.5)
            alignment_bonus, factors = self._calculate_alignment_from_dict(record, preference)
            updated_score = self._clamp_score(score + alignment_bonus)
            record["confidence_score"] = updated_score
            record["personalization_factors"] = factors
            scored_entries.append((updated_score, record))
            index += 1
        scored_entries.sort(key=lambda entry: entry[0], reverse=True)
        output: List[Dict[str, Any]] = []
        entry_index = 0
        while entry_index < len(scored_entries):
            output.append(scored_entries[entry_index][1])
            entry_index += 1
        return output

    async def integrate_feedback(self, feedback_data: Dict[str, Any]) -> Dict[str, Any]:
        """Record explicit user feedback to refine future personalization."""
        user_id = str(feedback_data.get("user_id", "anonymous"))
        recommendation_key = str(feedback_data.get("recommendation_id", uuid4()))
        rating = self._safe_float(feedback_data.get("rating"), 0.0)
        accepted_flag = bool(feedback_data.get("accepted", rating >= 3.0))
        comments = feedback_data.get("comments")

        feedback = RecommendationFeedback(
            user_id=user_id,
            recommendation_key=recommendation_key,
            rating=rating,
            accepted=accepted_flag,
            comments=comments,
        )
        async with self._lock:
            if user_id not in self._feedback_history:
                self._feedback_history[user_id] = []
            self._feedback_history[user_id].append(feedback)
            self._update_collaborative_matrix_with_feedback(feedback)
        logger.info("Integrated feedback for user %s on %s", user_id, recommendation_key)
        return {"status": "feedback integrated", "user_id": user_id}

    async def personalize_recommendations(
        self,
        request: RecommendationRequest,
        recommendations: List[RecommendationItem],
    ) -> Dict[str, Any]:
        """Generate personalized ordering and summary for recommendation items."""
        if recommendations is None:
            logger.warning("No recommendations supplied for personalization")
            return {"recommendations": [], "summary": {"insights": [], "applied_adjustments": [], "confidence": 0.0}}

        user_id = self._resolve_user_id(request)
        await self._ensure_preference_profile(user_id, request.user_preferences)
        preference = self._user_preferences.get(user_id)

        collaborative_scores = self._predict_collaborative_scores(user_id)
        personalized_records: List[Dict[str, Any]] = []
        total_confidence = 0.0
        insights: List[str] = []
        adjustments: List[str] = []

        for item in recommendations:
            key = self._build_recommendation_key(item)
            base_score = item.confidence_score
            alignment_score, alignment_notes = self._calculate_alignment_from_item(item, preference)
            collaborative_bonus = collaborative_scores.get(key, 0.0) * 0.2
            interaction_bonus = self._calculate_interaction_bonus(user_id, key)
            adjusted_score = self._clamp_score(base_score + alignment_score + collaborative_bonus + interaction_bonus)

            if alignment_notes:
                note_index = 0
                while note_index < len(alignment_notes):
                    note = alignment_notes[note_index]
                    insights.append(note)
                    note_index += 1
            if collaborative_bonus > 0.0:
                adjustments.append(f"Collaborative learning boosted {item.title}")
            if interaction_bonus > 0.0:
                adjustments.append(f"Recent activity reinforced {item.title}")

            updated_item = item.copy(update={"confidence_score": adjusted_score})
            record = {"score": adjusted_score, "item": updated_item, "key": key}
            personalized_records.append(record)
            total_confidence += adjusted_score

        personalized_records.sort(key=lambda entry: entry["score"], reverse=True)

        reordered: List[RecommendationItem] = []
        record_index = 0
        while record_index < len(personalized_records):
            reordered.append(personalized_records[record_index]["item"])
            record_index += 1

        average_confidence = 0.0
        if len(recommendations) > 0:
            average_confidence = total_confidence / float(len(recommendations))

        summary = {
            "insights": insights,
            "applied_adjustments": adjustments,
            "confidence": round(average_confidence, 3),
            "user_id": user_id,
        }

        return {"recommendations": reordered, "summary": summary}

    async def log_recommendation_delivery(
        self,
        request: RecommendationRequest,
        recommendations: List[RecommendationItem],
        personalization_summary: Optional[Dict[str, Any]],
    ) -> None:
        """Persist delivery metadata for future personalization cycles."""
        user_id = self._resolve_user_id(request)
        timestamp = datetime.utcnow()
        context: Dict[str, Any] = {}
        if personalization_summary:
            context = personalization_summary
        interaction_list: List[RecommendationInteraction] = []
        index = 0
        while index < len(recommendations):
            item = recommendations[index]
            interaction = RecommendationInteraction(
                user_id=user_id,
                recommendation_key=self._build_recommendation_key(item),
                delivered_at=timestamp,
                confidence_score=item.confidence_score,
                context=context,
            )
            interaction_list.append(interaction)
            index += 1
        async with self._lock:
            if user_id not in self._interaction_history:
                self._interaction_history[user_id] = []
            existing = self._interaction_history[user_id]
            for interaction in interaction_list:
                existing.append(interaction)
                self._update_collaborative_matrix_with_interaction(interaction)
        logger.debug("Logged %d recommendation deliveries for user %s", len(interaction_list), user_id)

    def _calculate_alignment_from_dict(
        self, record: Dict[str, Any], preference: UserPreference
    ) -> Tuple[float, List[str]]:
        """Score preference alignment for dictionary-based recommendations."""
        dummy_item = RecommendationItem(
            recommendation_type=str(record.get("recommendation_type", "unknown")),
            title=str(record.get("title", "Recommendation")),
            description=str(record.get("description", "")),
            priority=int(record.get("priority", 3)),
            confidence_score=self._safe_float(record.get("confidence_score"), 0.5),
            implementation_steps=list(record.get("implementation_steps", [])),
            expected_outcomes=list(record.get("expected_outcomes", [])),
            cost_estimate=self._safe_float(record.get("cost_estimate"), None),
            roi_estimate=self._safe_float(record.get("roi_estimate"), None),
            timing=str(record.get("timing")) if record.get("timing") else None,
            agricultural_sources=list(record.get("agricultural_sources", [])),
        )
        return self._calculate_alignment_from_item(dummy_item, preference)

    def _calculate_alignment_from_item(
        self, item: RecommendationItem, preference: Optional[UserPreference]
    ) -> Tuple[float, List[str]]:
        """Compute alignment score between a recommendation and stored preferences."""
        if preference is None:
            return 0.0, []
        score_adjustment = 0.0
        notes: List[str] = []

        title_lower = item.title.lower()
        if self._title_matches_preferences(title_lower, preference):
            score_adjustment += 0.08
            notes.append(f"Aligned to preferred focus in {item.title}")

        if preference.organic_focus:
            matched = self._contains_keyword(item.description, "organic")
            if matched:
                score_adjustment += 0.05
                notes.append("Elevated organic practice alignment")

        if preference.sustainability_priority > 0.6:
            matched = self._contains_keyword(item.description, "cover crop")
            if matched:
                score_adjustment += 0.05
                notes.append("Sustainability focus matched")

        if preference.yield_priority > 0.6:
            matched = self._contains_keyword(item.description, "yield")
            if matched:
                score_adjustment += 0.04
                notes.append("Yield objective highlighted")

        if preference.cost_sensitivity > 0.6 and item.cost_estimate:
            if item.cost_estimate <= 0:
                score_adjustment += 0.03
                notes.append("Low-cost strategy favoured")
            elif item.cost_estimate < 100.0:
                score_adjustment += 0.015

        if preference.management_style == "low_input" and item.priority > 3:
            score_adjustment -= 0.03
            notes.append("Reduced emphasis on high-effort option")

        if preference.risk_tolerance == "low" and item.priority == 1:
            score_adjustment -= 0.02
            notes.append("Tempered aggressive recommendation")

        return score_adjustment, notes

    def _title_matches_preferences(self, title_lower: str, preference: UserPreference) -> bool:
        """Check if the recommendation title matches explicit preferences."""
        if not title_lower:
            return False
        index = 0
        while index < len(preference.preferred_crops):
            crop_name = preference.preferred_crops[index]
            if crop_name.lower() in title_lower:
                return True
            index += 1
        keyword_index = 0
        while keyword_index < len(preference.focus_keywords):
            keyword = preference.focus_keywords[keyword_index]
            if keyword.lower() in title_lower:
                return True
            keyword_index += 1
        return False

    def _contains_keyword(self, text: Optional[str], keyword: str) -> bool:
        """Simple pattern matcher for keyword presence (case-insensitive)."""
        if not text:
            return False
        lowered = text.lower()
        return keyword.lower() in lowered

    def _calculate_interaction_bonus(self, user_id: str, recommendation_key: str) -> float:
        """Reward recommendations similar to recent positive interactions."""
        history = self._interaction_history.get(user_id)
        if not history:
            return 0.0
        bonus = 0.0
        now = datetime.utcnow()
        index = len(history) - 1
        checked = 0
        while index >= 0 and checked < 5:
            interaction = history[index]
            age_seconds = (now - interaction.delivered_at).total_seconds()
            if interaction.recommendation_key == recommendation_key and age_seconds < 86400:
                bonus += 0.05
            index -= 1
            checked += 1
        return bonus

    def _predict_collaborative_scores(self, user_id: str) -> Dict[str, float]:
        """Estimate recommendation scores using collaborative feedback."""
        predictions: Dict[str, float] = {}
        current_vector = self._collaborative_matrix.get(user_id, {})
        for other_user, vector in self._collaborative_matrix.items():
            if other_user == user_id:
                continue
            similarity = self._cosine_similarity(current_vector, vector)
            if similarity <= 0.0:
                continue
            for rec_key, rating in vector.items():
                if rec_key in current_vector:
                    continue
                if rec_key not in predictions:
                    predictions[rec_key] = 0.0
                predictions[rec_key] += rating * similarity
        return predictions

    def _update_collaborative_matrix_with_feedback(self, feedback: RecommendationFeedback) -> None:
        """Update collaborative matrix using explicit feedback."""
        user_vector = self._collaborative_matrix.get(feedback.user_id)
        if user_vector is None:
            self._collaborative_matrix[feedback.user_id] = {}
            user_vector = self._collaborative_matrix[feedback.user_id]
        user_vector[feedback.recommendation_key] = feedback.rating

    def _update_collaborative_matrix_with_interaction(self, interaction: RecommendationInteraction) -> None:
        """Record implicit interaction as low-weight collaborative signal."""
        user_vector = self._collaborative_matrix.get(interaction.user_id)
        if user_vector is None:
            self._collaborative_matrix[interaction.user_id] = {}
            user_vector = self._collaborative_matrix[interaction.user_id]
        if interaction.recommendation_key not in user_vector:
            user_vector[interaction.recommendation_key] = interaction.confidence_score * 0.2

    async def _ensure_preference_profile(
        self, user_id: str, user_preferences_payload: Optional[Dict[str, Any]]
    ) -> None:
        """Ensure a preference profile exists, creating one if necessary."""
        async with self._lock:
            if user_id in self._user_preferences:
                if user_preferences_payload:
                    updated = self._parse_user_preference(user_id, user_preferences_payload)
                    self._user_preferences[user_id] = updated
                return
            self._user_preferences[user_id] = self._parse_user_preference(user_id, user_preferences_payload or {})

    def _parse_user_preference(self, user_id: str, payload: Dict[str, Any]) -> UserPreference:
        """Normalize raw preference payload into `UserPreference`."""
        risk = str(payload.get("risk_tolerance", "moderate")).lower()
        if risk not in ("low", "moderate", "high"):
            risk = "moderate"
        management = str(payload.get("management_intensity", "balanced")).lower()
        if management not in ("low_input", "balanced", "high_intensity"):
            if management in ("low", "low_input_management"):
                management = "low_input"
            elif management in ("high", "intensive"):
                management = "high_intensity"
            else:
                management = "balanced"
        organic_focus = bool(payload.get("organic_focus", False))
        yield_priority = self._safe_float(payload.get("yield_priority"), 0.5)
        sustainability_priority = self._safe_float(payload.get("sustainability_priority"), 0.5)
        profit_priority = self._safe_float(payload.get("profit_priority"), 0.5)
        if profit_priority == 0.5 and "economic_priority" in payload:
            profit_priority = self._safe_float(payload.get("economic_priority"), 0.5)
        cost_sensitivity = self._safe_float(payload.get("cost_sensitivity"), 0.5)
        if cost_sensitivity == 0.5:
            cost_sensitivity = 1.0 - profit_priority
            if cost_sensitivity < 0.0:
                cost_sensitivity = 0.0
            if cost_sensitivity > 1.0:
                cost_sensitivity = 1.0

        preferred_crops: List[str] = []
        crops_value = payload.get("preferred_crops")
        if isinstance(crops_value, list):
            crop_index = 0
            while crop_index < len(crops_value):
                crop_name = str(crops_value[crop_index]).strip()
                if crop_name:
                    preferred_crops.append(crop_name)
                crop_index += 1

        focus_keywords: List[str] = []
        keywords_value = payload.get("focus_keywords")
        if isinstance(keywords_value, list):
            keyword_index = 0
            while keyword_index < len(keywords_value):
                keyword = str(keywords_value[keyword_index]).strip()
                if keyword:
                    focus_keywords.append(keyword)
                keyword_index += 1

        constraints = {}
        constraint_value = payload.get("constraints")
        if isinstance(constraint_value, dict):
            constraints = constraint_value

        preference = UserPreference(
            user_id=user_id,
            risk_tolerance=risk,
            management_style=management,
            organic_focus=organic_focus,
            yield_priority=self._normalize_priority(yield_priority),
            sustainability_priority=self._normalize_priority(sustainability_priority),
            profit_priority=self._normalize_priority(profit_priority),
            cost_sensitivity=self._normalize_priority(cost_sensitivity),
            preferred_crops=preferred_crops,
            focus_keywords=focus_keywords,
            constraints=constraints,
            last_updated=datetime.utcnow(),
        )
        return preference

    def _normalize_priority(self, value: float) -> float:
        """Clamp priority values to the supported 0-1 range."""
        if value is None:
            return 0.5
        if value < 0.0:
            return 0.0
        if value > 1.0:
            return 1.0
        return value

    def _resolve_user_id(self, request: RecommendationRequest) -> str:
        """Resolve stable user identifier from the request payload."""
        if request.additional_context and "user_id" in request.additional_context:
            identifier = str(request.additional_context["user_id"])
            if identifier:
                return identifier
        if request.farm_profile and request.farm_profile.farm_id:
            return request.farm_profile.farm_id
        return request.request_id

    def _build_recommendation_key(self, item: RecommendationItem) -> str:
        """Create a consistent identifier for a recommendation item."""
        parts: List[str] = []
        if item.recommendation_type:
            parts.append(item.recommendation_type.lower())
        if item.title:
            parts.append(item.title.lower())
        if item.timing:
            parts.append(str(item.timing).lower())
        if not parts:
            parts.append(str(uuid4()))
        key = "::".join(parts)
        return key

    def _safe_float(self, value: Any, default: Optional[float]) -> Optional[float]:
        """Convert arbitrary values to float with fallback."""
        if value is None:
            return default
        try:
            return float(value)
        except (TypeError, ValueError):
            return default

    def _clamp_score(self, value: float) -> float:
        """Ensure confidence scores stay within valid bounds."""
        if value < 0.0:
            return 0.0
        if value > 1.0:
            return 1.0
        return value

    def _cosine_similarity(self, vector_a: Dict[str, float], vector_b: Dict[str, float]) -> float:
        """Calculate cosine similarity between two sparse rating vectors."""
        if not vector_a or not vector_b:
            return 0.0
        dot_product = 0.0
        magnitude_a = 0.0
        magnitude_b = 0.0
        for key, value in vector_a.items():
            magnitude_a += value * value
            if key in vector_b:
                dot_product += value * vector_b[key]
        for value in vector_b.values():
            magnitude_b += value * value
        if magnitude_a <= 0.0 or magnitude_b <= 0.0:
            return 0.0
        similarity = dot_product / ((magnitude_a ** 0.5) * (magnitude_b ** 0.5))
        return similarity
